// src/radio-group.anatomy.ts
import { createAnatomy } from "@zag-js/anatomy";
var anatomy = createAnatomy("radio-group").parts(
  "root",
  "label",
  "radio",
  "radioLabel",
  "radioControl",
  "radioInput",
  "indicator"
);
var parts = anatomy.build();

// src/radio-group.connect.ts
import { ariaAttr, dataAttr } from "@zag-js/dom-query";
import { visuallyHiddenStyle } from "@zag-js/visually-hidden";

// src/radio-group.dom.ts
import { createScope, queryAll } from "@zag-js/dom-query";
var dom = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `radio-group:${ctx.id}`,
  getLabelId: (ctx) => ctx.ids?.label ?? `radio-group:${ctx.id}:label`,
  getRadioId: (ctx, value) => ctx.ids?.radio?.(value) ?? `radio-group:${ctx.id}:radio:${value}`,
  getRadioInputId: (ctx, value) => ctx.ids?.radioInput?.(value) ?? `radio-group:${ctx.id}:radio:input:${value}`,
  getRadioControlId: (ctx, value) => ctx.ids?.radioControl?.(value) ?? `radio-group:${ctx.id}:radio:control:${value}`,
  getRadioLabelId: (ctx, value) => ctx.ids?.radioLabel?.(value) ?? `radio-group:${ctx.id}:radio:label:${value}`,
  getIndicatorId: (ctx) => ctx.ids?.indicator ?? `tabs:${ctx.id}:indicator`,
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getRadioInputEl: (ctx, value) => dom.getById(ctx, dom.getRadioInputId(ctx, value)),
  getIndicatorEl: (ctx) => dom.getById(ctx, dom.getIndicatorId(ctx)),
  getFirstEnabledInputEl: (ctx) => dom.getRootEl(ctx)?.querySelector("input:not(:disabled)"),
  getFirstEnabledAndCheckedInputEl: (ctx) => dom.getRootEl(ctx)?.querySelector("input:not(:disabled):checked"),
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom.getRootId(ctx));
    const selector = `input[type=radio][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom.getRootEl(ctx), selector);
  },
  getActiveRadioEl: (ctx) => {
    if (!ctx.value)
      return;
    return dom.getById(ctx, dom.getRadioId(ctx, ctx.value));
  },
  getOffsetRect: (el) => {
    return {
      left: el?.offsetLeft ?? 0,
      top: el?.offsetTop ?? 0,
      width: el?.offsetWidth ?? 0,
      height: el?.offsetHeight ?? 0
    };
  },
  getRectById: (ctx, id) => {
    const tab = dom.queryById(ctx, dom.getRadioId(ctx, id));
    return dom.resolveRect(dom.getOffsetRect(tab));
  },
  resolveRect(rect) {
    return {
      width: `${rect.width}px`,
      height: `${rect.height}px`,
      left: `${rect.left}px`,
      top: `${rect.top}px`
    };
  }
});

// src/radio-group.connect.ts
function connect(state, send, normalize) {
  const isGroupDisabled = state.context.disabled;
  function getRadioState(props) {
    const radioState = {
      isInvalid: props.invalid,
      isDisabled: props.disabled || isGroupDisabled,
      isChecked: state.context.value === props.value,
      isFocused: state.context.focusedId === props.value,
      isHovered: state.context.hoveredId === props.value,
      isActive: state.context.activeId === props.value
    };
    return {
      ...radioState,
      isInteractive: !radioState.isDisabled
    };
  }
  function getRadioDataAttrs(props) {
    const radioState = getRadioState(props);
    return {
      "data-focus": dataAttr(radioState.isFocused),
      "data-disabled": dataAttr(radioState.isDisabled),
      "data-state": radioState.isChecked ? "checked" : "unchecked",
      "data-hover": dataAttr(radioState.isHovered),
      "data-invalid": dataAttr(radioState.isInvalid)
    };
  }
  const focus = () => {
    const firstEnabledAndCheckedInput = dom.getFirstEnabledAndCheckedInputEl(state.context);
    if (firstEnabledAndCheckedInput) {
      firstEnabledAndCheckedInput.focus();
      return;
    }
    const firstEnabledInput = dom.getFirstEnabledInputEl(state.context);
    firstEnabledInput?.focus();
  };
  return {
    value: state.context.value,
    setValue(value) {
      send({ type: "SET_VALUE", value, manual: true });
    },
    clearValue() {
      send({ type: "SET_VALUE", value: null, manual: true });
    },
    focus,
    blur() {
      const focusedElement = dom.getActiveElement(state.context);
      const inputEls = dom.getInputEls(state.context);
      const radioInputIsFocused = inputEls.some((el) => el === focusedElement);
      if (radioInputIsFocused)
        focusedElement?.blur();
    },
    getRadioState,
    rootProps: normalize.element({
      ...parts.root.attrs,
      role: "radiogroup",
      id: dom.getRootId(state.context),
      "aria-labelledby": dom.getLabelId(state.context),
      "data-orientation": state.context.orientation,
      "aria-orientation": state.context.orientation,
      dir: state.context.dir
    }),
    labelProps: normalize.element({
      ...parts.label.attrs,
      id: dom.getLabelId(state.context),
      onClick: focus
    }),
    getRadioProps(props) {
      const rootState = getRadioState(props);
      return normalize.label({
        ...parts.radio.attrs,
        id: dom.getRadioId(state.context, props.value),
        htmlFor: dom.getRadioInputId(state.context, props.value),
        ...getRadioDataAttrs(props),
        onPointerMove() {
          if (!rootState.isInteractive)
            return;
          send({ type: "SET_HOVERED", value: props.value, hovered: true });
        },
        onPointerLeave() {
          if (!rootState.isInteractive)
            return;
          send({ type: "SET_HOVERED", value: null });
        },
        onPointerDown(event) {
          if (!rootState.isInteractive)
            return;
          if (rootState.isFocused && event.pointerType === "mouse") {
            event.preventDefault();
          }
          send({ type: "SET_ACTIVE", value: props.value, active: true });
        },
        onPointerUp() {
          if (!rootState.isInteractive)
            return;
          send({ type: "SET_ACTIVE", value: null });
        }
      });
    },
    getRadioLabelProps(props) {
      return normalize.element({
        ...parts.radioLabel.attrs,
        id: dom.getRadioLabelId(state.context, props.value),
        ...getRadioDataAttrs(props)
      });
    },
    getRadioControlProps(props) {
      const controlState = getRadioState(props);
      return normalize.element({
        ...parts.radioControl.attrs,
        id: dom.getRadioControlId(state.context, props.value),
        "data-active": dataAttr(controlState.isActive),
        "aria-hidden": true,
        ...getRadioDataAttrs(props)
      });
    },
    getRadioInputProps(props) {
      const inputState = getRadioState(props);
      const isRequired = props.required;
      const trulyDisabled = inputState.isDisabled && !props.focusable;
      return normalize.input({
        ...parts.radioInput.attrs,
        "data-ownedby": dom.getRootId(state.context),
        id: dom.getRadioInputId(state.context, props.value),
        type: "radio",
        name: state.context.name || state.context.id,
        form: state.context.form,
        value: props.value,
        onChange(event) {
          if (inputState.isDisabled)
            return;
          if (event.target.checked) {
            send({ type: "SET_VALUE", value: props.value });
          }
        },
        onBlur() {
          send({ type: "SET_FOCUSED", value: null });
        },
        onFocus() {
          send({ type: "SET_FOCUSED", value: props.value, focused: true });
        },
        onKeyDown(event) {
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: props.value, active: true });
          }
        },
        onKeyUp(event) {
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: null });
          }
        },
        disabled: trulyDisabled,
        required: isRequired,
        defaultChecked: inputState.isChecked,
        "data-disabled": dataAttr(inputState.isDisabled),
        "aria-required": ariaAttr(isRequired),
        "aria-invalid": ariaAttr(inputState.isInvalid),
        "aria-disabled": ariaAttr(trulyDisabled),
        "aria-checked": ariaAttr(inputState.isChecked),
        style: visuallyHiddenStyle
      });
    },
    indicatorProps: normalize.element({
      id: dom.getIndicatorId(state.context),
      ...parts.indicator.attrs,
      "data-orientation": state.context.orientation,
      style: {
        "--transition-duration": "150ms",
        "--transition-property": "left, top, width, height",
        position: "absolute",
        willChange: "var(--transition-property)",
        transitionProperty: "var(--transition-property)",
        transitionDuration: state.context.canIndicatorTransition ? "var(--transition-duration)" : "0ms",
        transitionTimingFunction: "var(--transition-timing-function)",
        ...state.context.indicatorRect
      }
    })
  };
}

// src/radio-group.machine.ts
import { createMachine } from "@zag-js/core";
import { nextTick } from "@zag-js/dom-query";
import { trackElementRect } from "@zag-js/element-rect";
import { trackFormControl } from "@zag-js/form-utils";
import { compact, isString } from "@zag-js/utils";
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "radio",
      initial: "idle",
      context: {
        value: null,
        activeId: null,
        focusedId: null,
        hoveredId: null,
        indicatorRect: {},
        canIndicatorTransition: false,
        ...ctx
      },
      entry: ["syncIndicatorRect"],
      exit: ["cleanupObserver"],
      activities: ["trackFormControlState"],
      watch: {
        value: [
          "setIndicatorTransition",
          // important to set this after `setIndicatorTransition`
          "setPreviousValue",
          "invokeOnChange",
          "syncIndicatorRect",
          "syncInputElements"
        ]
      },
      on: {
        SET_VALUE: {
          actions: ["setValue"]
        },
        SET_HOVERED: {
          actions: "setHovered"
        },
        SET_ACTIVE: {
          actions: "setActive"
        },
        SET_FOCUSED: {
          actions: "setFocused"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      activities: {
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom.getRootEl(ctx2), {
            onFieldsetDisabled() {
              ctx2.disabled = true;
            },
            onFormReset() {
              send({ type: "SET_VALUE", value: initialContext.value });
            }
          });
        }
      },
      actions: {
        setValue(ctx2, evt) {
          ctx2.value = evt.value;
        },
        setHovered(ctx2, evt) {
          ctx2.hoveredId = evt.value;
        },
        setActive(ctx2, evt) {
          ctx2.activeId = evt.value;
        },
        setFocused(ctx2, evt) {
          ctx2.focusedId = evt.value;
        },
        invokeOnChange(ctx2, evt) {
          ctx2.onChange?.({ value: evt.value });
        },
        syncInputElements(ctx2) {
          const inputs = dom.getInputEls(ctx2);
          inputs.forEach((input) => {
            input.checked = input.value === ctx2.value;
          });
        },
        setIndicatorTransition(ctx2) {
          ctx2.canIndicatorTransition = isString(ctx2.value);
        },
        cleanupObserver(ctx2) {
          ctx2.indicatorCleanup?.();
        },
        syncIndicatorRect(ctx2) {
          ctx2.indicatorCleanup?.();
          if (!dom.getIndicatorEl(ctx2))
            return;
          const value = ctx2.value;
          if (value == null) {
            ctx2.indicatorRect = {};
            return;
          }
          const radioEl = dom.getActiveRadioEl(ctx2);
          if (!radioEl)
            return;
          ctx2.indicatorCleanup = trackElementRect(radioEl, {
            getRect(el) {
              return dom.getOffsetRect(el);
            },
            onChange(rect) {
              ctx2.indicatorRect = dom.resolveRect(rect);
              nextTick(() => {
                ctx2.canIndicatorTransition = false;
              });
            }
          });
        }
      }
    }
  );
}
export {
  anatomy,
  connect,
  machine
};
//# sourceMappingURL=index.mjs.map