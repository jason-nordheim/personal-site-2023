"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  anatomy: () => anatomy,
  connect: () => connect,
  machine: () => machine
});
module.exports = __toCommonJS(src_exports);

// src/select.anatomy.ts
var import_anatomy = require("@zag-js/anatomy");
var anatomy = (0, import_anatomy.createAnatomy)("select").parts(
  "label",
  "positioner",
  "trigger",
  "option",
  "optionGroup",
  "optionGroupLabel",
  "hiddenSelect",
  "content"
);
var parts = anatomy.build();

// src/select.connect.ts
var import_dom_event = require("@zag-js/dom-event");
var import_dom_query2 = require("@zag-js/dom-query");
var import_popper = require("@zag-js/popper");
var import_visually_hidden = require("@zag-js/visually-hidden");

// src/select.dom.ts
var import_dom_query = require("@zag-js/dom-query");
var dom = (0, import_dom_query.createScope)({
  getContentId: (ctx) => ctx.ids?.content ?? `select:${ctx.id}:content`,
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `select:${ctx.id}:trigger`,
  getLabelId: (ctx) => ctx.ids?.label ?? `select:${ctx.id}:label`,
  getOptionId: (ctx, id) => ctx.ids?.option?.(id) ?? `select:${ctx.id}:option:${id}`,
  getHiddenSelectId: (ctx) => ctx.ids?.hiddenSelect ?? `select:${ctx.id}:select`,
  getPositionerId: (ctx) => ctx.ids?.positioner ?? `select:${ctx.id}:positioner`,
  getOptionGroupId: (ctx, id) => ctx.ids?.optionGroup?.(id) ?? `select:${ctx.id}:optgroup:${id}`,
  getOptionGroupLabelId: (ctx, id) => ctx.ids?.optionGroupLabel?.(id) ?? `select:${ctx.id}:optgroup-label:${id}`,
  getHiddenSelectElement: (ctx) => dom.getById(ctx, dom.getHiddenSelectId(ctx)),
  getContentElement: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),
  getTriggerElement: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),
  getPositionerElement: (ctx) => {
    return dom.getById(ctx, dom.getPositionerId(ctx));
  },
  getOptionElements: (ctx) => {
    return (0, import_dom_query.queryAll)(dom.getContentElement(ctx), "[role=option]:not([data-disabled])");
  },
  getFirstOption: (ctx) => {
    return (0, import_dom_query.query)(dom.getContentElement(ctx), "[role=option]:not([data-disabled])");
  },
  getLastOption: (ctx) => {
    return (0, import_dom_query.query)(dom.getContentElement(ctx), "[role=option]:not([data-disabled]):last-of-type");
  },
  getNextOption: (ctx, currentId) => {
    const options = dom.getOptionElements(ctx);
    return (0, import_dom_query.nextById)(options, currentId, ctx.loop);
  },
  getPreviousOption: (ctx, currentId) => {
    const options = dom.getOptionElements(ctx);
    return (0, import_dom_query.prevById)(options, currentId, ctx.loop);
  },
  getOptionDetails(option) {
    const { label, value } = option.dataset;
    return { label, value };
  },
  getMatchingOption(ctx, key, current) {
    return (0, import_dom_query.getByTypeahead)(dom.getOptionElements(ctx), { state: ctx.typeahead, key, activeId: current });
  },
  getHighlightedOption(ctx) {
    if (!ctx.highlightedId)
      return null;
    return dom.getById(ctx, ctx.highlightedId);
  },
  getClosestOption(target) {
    return (0, import_dom_query.isHTMLElement)(target) ? target.closest("[data-part=option]") : null;
  }
});

// src/select.utils.ts
var import_utils = require("@zag-js/utils");
function isOptionData(v) {
  return (0, import_utils.isObject)(v) && "value" in v && "label" in v;
}
function validateOptionData(v) {
  if (!isOptionData(v)) {
    throw new TypeError("Expected an option data object");
  }
}

// src/select.connect.ts
function connect(state, send, normalize) {
  const disabled = state.context.disabled;
  const invalid = state.context.invalid;
  const isInteractive = state.context.isInteractive;
  const isOpen = state.matches("open");
  const highlightedOption = state.context.highlightedOption;
  const selectedOption = state.context.selectedOption;
  const isTypingAhead = state.context.isTypingAhead;
  function getOptionState(props) {
    const id = dom.getOptionId(state.context, props.value);
    return {
      isDisabled: Boolean(props.disabled || disabled),
      isHighlighted: state.context.highlightedId === id,
      isChecked: state.context.selectedOption?.value === props.value
    };
  }
  const popperStyles = (0, import_popper.getPlacementStyles)({
    placement: state.context.currentPlacement
  });
  return {
    isOpen,
    highlightedOption,
    selectedOption,
    focus() {
      dom.getTriggerElement(state.context)?.focus();
    },
    open() {
      send("OPEN");
    },
    close() {
      send("CLOSE");
    },
    setSelectedOption(value) {
      validateOptionData(value);
      send({ type: "SELECT_OPTION", value });
    },
    setHighlightedOption(value) {
      validateOptionData(value);
      send({ type: "HIGHLIGHT_OPTION", value });
    },
    clearSelectedOption() {
      send({ type: "CLEAR_SELECTED" });
    },
    getOptionState,
    labelProps: normalize.label({
      dir: state.context.dir,
      id: dom.getLabelId(state.context),
      ...parts.label.attrs,
      "data-disabled": (0, import_dom_query2.dataAttr)(disabled),
      "data-invalid": (0, import_dom_query2.dataAttr)(invalid),
      "data-readonly": (0, import_dom_query2.dataAttr)(state.context.readOnly),
      htmlFor: dom.getHiddenSelectId(state.context),
      onClick() {
        if (disabled)
          return;
        dom.getTriggerElement(state.context)?.focus();
      }
    }),
    positionerProps: normalize.element({
      ...parts.positioner.attrs,
      id: dom.getPositionerId(state.context),
      style: popperStyles.floating
    }),
    triggerProps: normalize.button({
      id: dom.getTriggerId(state.context),
      disabled,
      dir: state.context.dir,
      type: "button",
      "aria-controls": dom.getContentId(state.context),
      "aria-expanded": isOpen,
      "data-state": isOpen ? "open" : "closed",
      "aria-haspopup": "listbox",
      "aria-labelledby": dom.getLabelId(state.context),
      ...parts.trigger.attrs,
      "data-disabled": (0, import_dom_query2.dataAttr)(disabled),
      "data-invalid": (0, import_dom_query2.dataAttr)(invalid),
      "aria-invalid": invalid,
      "data-readonly": (0, import_dom_query2.dataAttr)(state.context.readOnly),
      "data-placement": state.context.currentPlacement,
      "data-placeholder-shown": (0, import_dom_query2.dataAttr)(!state.context.hasSelectedOption),
      onPointerDown(event) {
        if (event.button || event.ctrlKey || !isInteractive)
          return;
        event.currentTarget.dataset.pointerType = event.pointerType;
        if (disabled || event.pointerType === "touch")
          return;
        send({ type: "TRIGGER_CLICK" });
      },
      onClick(event) {
        if (!isInteractive || event.button)
          return;
        if (event.currentTarget.dataset.pointerType === "touch") {
          send({ type: "TRIGGER_CLICK" });
        }
      },
      onFocus() {
        send("TRIGGER_FOCUS");
      },
      onBlur() {
        send("TRIGGER_BLUR");
      },
      onKeyDown(event) {
        if (!isInteractive)
          return;
        const keyMap = {
          ArrowUp() {
            send({ type: "ARROW_UP" });
          },
          ArrowDown() {
            send({ type: "ARROW_DOWN" });
          },
          ArrowLeft() {
            send({ type: "ARROW_LEFT" });
          },
          ArrowRight() {
            send({ type: "ARROW_RIGHT" });
          },
          Home() {
            send({ type: "HOME" });
          },
          Enter() {
            send({ type: "TRIGGER_CLICK" });
          },
          End() {
            send({ type: "END" });
          },
          Space(event2) {
            if (isTypingAhead) {
              send({ type: "TYPEAHEAD", key: event2.key });
            } else {
              send({ type: "TRIGGER_KEY" });
            }
          }
        };
        const exec = keyMap[(0, import_dom_event.getEventKey)(event, state.context)];
        if (exec) {
          exec(event);
          event.preventDefault();
          return;
        }
        if (import_dom_query2.getByTypeahead.isValidEvent(event)) {
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      }
    }),
    getOptionProps(props) {
      const { value, label, valueText } = props;
      const optionState = getOptionState(props);
      return normalize.element({
        id: dom.getOptionId(state.context, value),
        role: "option",
        ...parts.option.attrs,
        "data-label": label,
        "data-value": value,
        "data-valuetext": valueText ?? label,
        "aria-selected": optionState.isChecked,
        "data-state": optionState.isChecked ? "checked" : "unchecked",
        "data-highlighted": (0, import_dom_query2.dataAttr)(optionState.isHighlighted),
        "data-disabled": (0, import_dom_query2.dataAttr)(optionState.isDisabled),
        "aria-disabled": (0, import_dom_query2.ariaAttr)(optionState.isDisabled)
      });
    },
    getOptionGroupLabelProps(props) {
      const { htmlFor } = props;
      return normalize.element({
        id: dom.getOptionGroupId(state.context, htmlFor),
        role: "group",
        ...parts.optionGroupLabel.attrs
      });
    },
    getOptionGroupProps(props) {
      const { id } = props;
      return normalize.element({
        ...parts.optionGroup.attrs,
        "data-disabled": (0, import_dom_query2.dataAttr)(disabled),
        id: dom.getOptionGroupId(state.context, id),
        "aria-labelledby": dom.getOptionGroupLabelId(state.context, id)
      });
    },
    hiddenSelectProps: normalize.select({
      ...parts.hiddenSelect.attrs,
      name: state.context.name,
      form: state.context.form,
      disabled: !isInteractive,
      "aria-hidden": true,
      id: dom.getHiddenSelectId(state.context),
      defaultValue: state.context.selectedOption?.value,
      style: import_visually_hidden.visuallyHiddenStyle,
      tabIndex: -1,
      // Some browser extensions will focus the hidden select.
      // Let's forward the focus to the trigger.
      onFocus() {
        dom.getTriggerElement(state.context)?.focus();
      },
      "aria-labelledby": dom.getLabelId(state.context)
    }),
    contentProps: normalize.element({
      hidden: !isOpen,
      dir: state.context.dir,
      id: dom.getContentId(state.context),
      role: "listbox",
      ...parts.content.attrs,
      "data-state": isOpen ? "open" : "closed",
      "aria-activedescendant": state.context.highlightedId || "",
      "aria-labelledby": dom.getLabelId(state.context),
      tabIndex: 0,
      onPointerMove(event) {
        if (!isInteractive)
          return;
        const option = dom.getClosestOption(event.target);
        if (!option || option.hasAttribute("data-disabled")) {
          send({ type: "POINTER_LEAVE" });
        } else {
          send({ type: "POINTER_MOVE", id: option.id, target: option });
        }
      },
      onPointerUp(event) {
        if (!isInteractive)
          return;
        const option = dom.getClosestOption(event.target);
        if (!option || option.hasAttribute("data-disabled"))
          return;
        send({ type: "OPTION_CLICK", src: "pointerup", id: option.id });
      },
      onPointerLeave() {
        send({ type: "POINTER_LEAVE" });
      },
      onClick(event) {
        if (!isInteractive)
          return;
        const option = dom.getClosestOption(event.target);
        if (!option || option.hasAttribute("data-disabled"))
          return;
        send({ type: "OPTION_CLICK", src: "click", id: option.id });
      },
      onKeyDown(event) {
        if (!isInteractive || !(0, import_dom_query2.isSelfEvent)(event))
          return;
        const keyMap = {
          ArrowUp() {
            send({ type: "ARROW_UP" });
          },
          ArrowDown() {
            send({ type: "ARROW_DOWN" });
          },
          Home() {
            send({ type: "HOME" });
          },
          End() {
            send({ type: "END" });
          },
          Tab(event2) {
            if (event2.shiftKey)
              return;
            send({ type: "TAB" });
          },
          Enter() {
            send({ type: "TRIGGER_KEY" });
          },
          Space(event2) {
            if (isTypingAhead) {
              send({ type: "TYPEAHEAD", key: event2.key });
            } else {
              keyMap.Enter?.(event2);
            }
          }
        };
        const exec = keyMap[(0, import_dom_event.getEventKey)(event)];
        if (exec) {
          exec(event);
          event.preventDefault();
          return;
        }
        if ((0, import_dom_query2.isEditableElement)(event.target)) {
          return;
        }
        if (import_dom_query2.getByTypeahead.isValidEvent(event)) {
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      }
    })
  };
}

// src/select.machine.ts
var import_core = require("@zag-js/core");
var import_dismissable = require("@zag-js/dismissable");
var import_dom_query3 = require("@zag-js/dom-query");
var import_form_utils = require("@zag-js/form-utils");
var import_mutation_observer = require("@zag-js/mutation-observer");
var import_popper2 = require("@zag-js/popper");
var import_tabbable = require("@zag-js/tabbable");
var import_utils2 = require("@zag-js/utils");
function machine(userContext) {
  const ctx = (0, import_utils2.compact)(userContext);
  return (0, import_core.createMachine)(
    {
      id: "select",
      context: {
        selectOnTab: false,
        selectedOption: null,
        highlightedOption: null,
        loop: false,
        closeOnSelect: true,
        ...ctx,
        initialSelectedOption: null,
        prevSelectedOption: null,
        prevHighlightedOption: null,
        typeahead: import_dom_query3.getByTypeahead.defaultOptions,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        }
      },
      computed: {
        hasSelectedOption: (ctx2) => ctx2.selectedOption != null,
        isTypingAhead: (ctx2) => ctx2.typeahead.keysSoFar !== "",
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        selectedId: (ctx2) => ctx2.selectedOption ? dom.getOptionId(ctx2, ctx2.selectedOption.value) : null,
        highlightedId: (ctx2) => ctx2.highlightedOption ? dom.getOptionId(ctx2, ctx2.highlightedOption.value) : null,
        hasSelectedChanged: (ctx2) => ctx2.selectedOption?.value !== ctx2.prevSelectedOption?.value,
        hasHighlightedChanged: (ctx2) => ctx2.highlightedOption?.value !== ctx2.prevHighlightedOption?.value
      },
      initial: "idle",
      watch: {
        selectedOption: ["syncSelectValue", "dispatchChangeEvent"]
      },
      on: {
        HIGHLIGHT_OPTION: {
          actions: ["setHighlightedOption", "invokeOnHighlight"]
        },
        SELECT_OPTION: {
          actions: ["setSelectedOption", "invokeOnSelect"]
        },
        CLEAR_SELECTED: {
          actions: ["clearSelectedOption", "invokeOnSelect"]
        }
      },
      entry: ["setInitialSelectedOption"],
      activities: ["trackFormControlState"],
      states: {
        idle: {
          tags: ["closed"],
          on: {
            TRIGGER_CLICK: {
              target: "open"
            },
            TRIGGER_FOCUS: {
              target: "focused"
            },
            OPEN: {
              target: "open"
            }
          }
        },
        focused: {
          tags: ["closed"],
          entry: ["focusTrigger", "clearHighlightedOption"],
          on: {
            TRIGGER_CLICK: {
              target: "open"
            },
            TRIGGER_BLUR: {
              target: "idle",
              actions: ["clearHighlightedOption"]
            },
            TRIGGER_KEY: {
              target: "open"
            },
            ARROW_UP: {
              target: "open",
              actions: ["highlightLastOption", "invokeOnHighlight"]
            },
            ARROW_DOWN: {
              target: "open",
              actions: ["highlightFirstOption", "invokeOnHighlight"]
            },
            ARROW_LEFT: [
              {
                guard: "hasSelectedOption",
                actions: ["selectPreviousOption", "invokeOnSelect"]
              },
              {
                actions: ["selectLastOption", "invokeOnSelect"]
              }
            ],
            ARROW_RIGHT: [
              {
                guard: "hasSelectedOption",
                actions: ["selectNextOption", "invokeOnSelect"]
              },
              {
                actions: ["selectFirstOption", "invokeOnSelect"]
              }
            ],
            HOME: {
              actions: ["selectFirstOption", "invokeOnSelect"]
            },
            END: {
              actions: ["selectLastOption", "invokeOnSelect"]
            },
            TYPEAHEAD: {
              actions: ["selectMatchingOption", "invokeOnSelect"]
            },
            OPEN: {
              target: "open"
            }
          }
        },
        open: {
          tags: ["open"],
          entry: ["focusContent", "highlightSelectedOption", "invokeOnOpen"],
          exit: ["scrollContentToTop"],
          activities: ["trackInteractOutside", "computePlacement", "scrollToHighlightedOption", "proxyTabFocus"],
          on: {
            CLOSE: {
              target: "focused",
              actions: ["invokeOnClose"]
            },
            TRIGGER_CLICK: {
              target: "focused",
              actions: ["invokeOnClose"]
            },
            OPTION_CLICK: [
              {
                target: "focused",
                actions: ["selectHighlightedOption", "invokeOnSelect", "invokeOnClose"],
                guard: "closeOnSelect"
              },
              {
                actions: ["selectHighlightedOption", "invokeOnSelect"]
              }
            ],
            TRIGGER_KEY: [
              {
                target: "focused",
                actions: ["selectHighlightedOption", "invokeOnSelect", "invokeOnClose"],
                guard: "closeOnSelect"
              },
              {
                actions: ["selectHighlightedOption", "invokeOnSelect"]
              }
            ],
            BLUR: {
              target: "focused",
              actions: ["invokeOnClose"]
            },
            HOME: {
              actions: ["highlightFirstOption", "invokeOnHighlight"]
            },
            END: {
              actions: ["highlightLastOption", "invokeOnHighlight"]
            },
            ARROW_DOWN: [
              {
                guard: "hasHighlightedOption",
                actions: ["highlightNextOption", "invokeOnHighlight"]
              },
              {
                actions: ["highlightFirstOption", "invokeOnHighlight"]
              }
            ],
            ARROW_UP: [
              {
                guard: "hasHighlightedOption",
                actions: ["highlightPreviousOption", "invokeOnHighlight"]
              },
              {
                actions: ["highlightLastOption", "invokeOnHighlight"]
              }
            ],
            TYPEAHEAD: {
              actions: ["highlightMatchingOption", "invokeOnHighlight"]
            },
            POINTER_MOVE: {
              actions: ["highlightOption", "invokeOnHighlight"]
            },
            POINTER_LEAVE: {
              actions: ["clearHighlightedOption"]
            },
            TAB: [
              {
                target: "idle",
                actions: ["selectHighlightedOption", "invokeOnClose", "invokeOnSelect", "clearHighlightedOption"],
                guard: "selectOnTab"
              },
              {
                target: "idle",
                actions: ["invokeOnClose", "clearHighlightedOption"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        hasHighlightedOption: (ctx2) => ctx2.highlightedId != null,
        selectOnTab: (ctx2) => !!ctx2.selectOnTab,
        hasSelectedOption: (ctx2) => ctx2.hasSelectedOption,
        closeOnSelect: (ctx2) => !!ctx2.closeOnSelect
      },
      activities: {
        proxyTabFocus(ctx2) {
          return (0, import_tabbable.proxyTabFocus)(dom.getContentElement(ctx2), {
            triggerElement: dom.getTriggerElement(ctx2),
            onFocus(el) {
              (0, import_dom_query3.raf)(() => el.focus({ preventScroll: true }));
            }
          });
        },
        trackFormControlState(ctx2) {
          return (0, import_form_utils.trackFormControl)(dom.getHiddenSelectElement(ctx2), {
            onFieldsetDisabled() {
              ctx2.disabled = true;
            },
            onFormReset() {
              ctx2.prevSelectedOption = ctx2.selectedOption;
              ctx2.selectedOption = ctx2.initialSelectedOption;
            }
          });
        },
        trackInteractOutside(ctx2, _evt, { send }) {
          let focusable = false;
          return (0, import_dismissable.trackDismissableElement)(dom.getContentElement(ctx2), {
            exclude: [dom.getTriggerElement(ctx2)],
            onInteractOutside(event) {
              focusable = event.detail.focusable;
              ctx2.onInteractOutside?.(event);
            },
            onDismiss() {
              send({ type: "BLUR", src: "interact-outside", focusable });
            }
          });
        },
        computePlacement(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          return (0, import_popper2.getPlacement)(dom.getTriggerElement(ctx2), dom.getPositionerElement(ctx2), {
            ...ctx2.positioning,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        scrollToHighlightedOption(ctx2, _evt, { getState }) {
          const exec = () => {
            const state = getState();
            if (state.event.type === "POINTER_MOVE")
              return;
            const option = dom.getHighlightedOption(ctx2);
            option?.scrollIntoView({ block: "nearest" });
          };
          (0, import_dom_query3.raf)(() => {
            exec();
          });
          return (0, import_mutation_observer.observeAttributes)(dom.getContentElement(ctx2), ["aria-activedescendant"], exec);
        }
      },
      actions: {
        setInitialSelectedOption(ctx2) {
          ctx2.initialSelectedOption = ctx2.selectedOption;
        },
        highlightPreviousOption(ctx2) {
          if (!ctx2.highlightedId)
            return;
          const option = dom.getPreviousOption(ctx2, ctx2.highlightedId);
          highlightOption(ctx2, option);
        },
        highlightNextOption(ctx2) {
          if (!ctx2.highlightedId)
            return;
          const option = dom.getNextOption(ctx2, ctx2.highlightedId);
          highlightOption(ctx2, option);
        },
        highlightFirstOption(ctx2) {
          const option = dom.getFirstOption(ctx2);
          highlightOption(ctx2, option);
        },
        highlightLastOption(ctx2) {
          const option = dom.getLastOption(ctx2);
          highlightOption(ctx2, option);
        },
        focusContent(ctx2) {
          (0, import_dom_query3.raf)(() => {
            dom.getContentElement(ctx2)?.focus({ preventScroll: true });
          });
        },
        focusTrigger(ctx2, evt) {
          if (evt.focusable)
            return;
          (0, import_dom_query3.raf)(() => {
            dom.getTriggerElement(ctx2)?.focus({ preventScroll: true });
          });
        },
        selectHighlightedOption(ctx2, evt) {
          const id = evt.id ?? ctx2.highlightedId;
          if (!id)
            return;
          const option = dom.getById(ctx2, id);
          selectOption(ctx2, option);
        },
        selectFirstOption(ctx2) {
          const option = dom.getFirstOption(ctx2);
          selectOption(ctx2, option);
        },
        selectLastOption(ctx2) {
          const option = dom.getLastOption(ctx2);
          selectOption(ctx2, option);
        },
        selectNextOption(ctx2) {
          if (!ctx2.selectedId)
            return;
          const option = dom.getNextOption(ctx2, ctx2.selectedId);
          selectOption(ctx2, option);
        },
        selectPreviousOption(ctx2) {
          if (!ctx2.selectedId)
            return;
          const option = dom.getPreviousOption(ctx2, ctx2.selectedId);
          selectOption(ctx2, option);
        },
        highlightSelectedOption(ctx2) {
          if (!ctx2.selectedOption)
            return;
          ctx2.prevHighlightedOption = ctx2.highlightedOption;
          ctx2.highlightedOption = ctx2.selectedOption;
        },
        highlightOption(ctx2, evt) {
          const option = evt.target ?? dom.getById(ctx2, evt.id);
          highlightOption(ctx2, option);
        },
        highlightMatchingOption(ctx2, evt) {
          const option = dom.getMatchingOption(ctx2, evt.key, ctx2.highlightedId);
          highlightOption(ctx2, option);
        },
        selectMatchingOption(ctx2, evt) {
          const option = dom.getMatchingOption(ctx2, evt.key, ctx2.selectedId);
          selectOption(ctx2, option);
        },
        setHighlightedOption(ctx2, evt) {
          if (!evt.value)
            return;
          ctx2.prevHighlightedOption = ctx2.highlightedOption;
          ctx2.highlightedOption = evt.value;
        },
        clearHighlightedOption(ctx2) {
          ctx2.highlightedOption = null;
        },
        setSelectedOption(ctx2, evt) {
          if (!evt.value)
            return;
          ctx2.prevSelectedOption = ctx2.selectedOption;
          ctx2.selectedOption = evt.value;
        },
        clearSelectedOption(ctx2) {
          ctx2.selectedOption = null;
        },
        scrollContentToTop(ctx2) {
          dom.getContentElement(ctx2)?.scrollTo(0, 0);
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpen?.();
        },
        invokeOnClose(ctx2) {
          ctx2.onClose?.();
        },
        invokeOnHighlight(ctx2) {
          if (!ctx2.hasHighlightedChanged)
            return;
          ctx2.onHighlight?.((0, import_utils2.json)(ctx2.highlightedOption));
        },
        invokeOnSelect(ctx2) {
          if (!ctx2.hasSelectedChanged)
            return;
          ctx2.onChange?.((0, import_utils2.json)(ctx2.selectedOption));
        },
        syncSelectValue(ctx2) {
          const selectedOption = ctx2.selectedOption;
          const node = dom.getHiddenSelectElement(ctx2);
          if (!node || !selectedOption)
            return;
          (0, import_form_utils.setElementValue)(node, selectedOption.value, { type: "HTMLSelectElement" });
        },
        dispatchChangeEvent(ctx2) {
          const node = dom.getHiddenSelectElement(ctx2);
          if (!node)
            return;
          const win = dom.getWin(ctx2);
          const changeEvent = new win.Event("change", { bubbles: true });
          node.dispatchEvent(changeEvent);
        }
      }
    }
  );
}
function highlightOption(ctx, option) {
  if (!option)
    return;
  ctx.prevHighlightedOption = ctx.highlightedOption;
  ctx.highlightedOption = dom.getOptionDetails(option);
}
function selectOption(ctx, option) {
  if (!option)
    return;
  ctx.prevSelectedOption = ctx.selectedOption;
  ctx.selectedOption = dom.getOptionDetails(option);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  anatomy,
  connect,
  machine
});
//# sourceMappingURL=index.js.map