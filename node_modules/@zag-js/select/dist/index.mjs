// src/select.anatomy.ts
import { createAnatomy } from "@zag-js/anatomy";
var anatomy = createAnatomy("select").parts(
  "label",
  "positioner",
  "trigger",
  "option",
  "optionGroup",
  "optionGroupLabel",
  "hiddenSelect",
  "content"
);
var parts = anatomy.build();

// src/select.connect.ts
import { getEventKey } from "@zag-js/dom-event";
import { ariaAttr, dataAttr, getByTypeahead as getByTypeahead2, isEditableElement, isSelfEvent } from "@zag-js/dom-query";
import { getPlacementStyles } from "@zag-js/popper";
import { visuallyHiddenStyle } from "@zag-js/visually-hidden";

// src/select.dom.ts
import { createScope, isHTMLElement, nextById, prevById, query, queryAll, getByTypeahead } from "@zag-js/dom-query";
var dom = createScope({
  getContentId: (ctx) => ctx.ids?.content ?? `select:${ctx.id}:content`,
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `select:${ctx.id}:trigger`,
  getLabelId: (ctx) => ctx.ids?.label ?? `select:${ctx.id}:label`,
  getOptionId: (ctx, id) => ctx.ids?.option?.(id) ?? `select:${ctx.id}:option:${id}`,
  getHiddenSelectId: (ctx) => ctx.ids?.hiddenSelect ?? `select:${ctx.id}:select`,
  getPositionerId: (ctx) => ctx.ids?.positioner ?? `select:${ctx.id}:positioner`,
  getOptionGroupId: (ctx, id) => ctx.ids?.optionGroup?.(id) ?? `select:${ctx.id}:optgroup:${id}`,
  getOptionGroupLabelId: (ctx, id) => ctx.ids?.optionGroupLabel?.(id) ?? `select:${ctx.id}:optgroup-label:${id}`,
  getHiddenSelectElement: (ctx) => dom.getById(ctx, dom.getHiddenSelectId(ctx)),
  getContentElement: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),
  getTriggerElement: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),
  getPositionerElement: (ctx) => {
    return dom.getById(ctx, dom.getPositionerId(ctx));
  },
  getOptionElements: (ctx) => {
    return queryAll(dom.getContentElement(ctx), "[role=option]:not([data-disabled])");
  },
  getFirstOption: (ctx) => {
    return query(dom.getContentElement(ctx), "[role=option]:not([data-disabled])");
  },
  getLastOption: (ctx) => {
    return query(dom.getContentElement(ctx), "[role=option]:not([data-disabled]):last-of-type");
  },
  getNextOption: (ctx, currentId) => {
    const options = dom.getOptionElements(ctx);
    return nextById(options, currentId, ctx.loop);
  },
  getPreviousOption: (ctx, currentId) => {
    const options = dom.getOptionElements(ctx);
    return prevById(options, currentId, ctx.loop);
  },
  getOptionDetails(option) {
    const { label, value } = option.dataset;
    return { label, value };
  },
  getMatchingOption(ctx, key, current) {
    return getByTypeahead(dom.getOptionElements(ctx), { state: ctx.typeahead, key, activeId: current });
  },
  getHighlightedOption(ctx) {
    if (!ctx.highlightedId)
      return null;
    return dom.getById(ctx, ctx.highlightedId);
  },
  getClosestOption(target) {
    return isHTMLElement(target) ? target.closest("[data-part=option]") : null;
  }
});

// src/select.utils.ts
import { isObject } from "@zag-js/utils";
function isOptionData(v) {
  return isObject(v) && "value" in v && "label" in v;
}
function validateOptionData(v) {
  if (!isOptionData(v)) {
    throw new TypeError("Expected an option data object");
  }
}

// src/select.connect.ts
function connect(state, send, normalize) {
  const disabled = state.context.disabled;
  const invalid = state.context.invalid;
  const isInteractive = state.context.isInteractive;
  const isOpen = state.matches("open");
  const highlightedOption = state.context.highlightedOption;
  const selectedOption = state.context.selectedOption;
  const isTypingAhead = state.context.isTypingAhead;
  function getOptionState(props) {
    const id = dom.getOptionId(state.context, props.value);
    return {
      isDisabled: Boolean(props.disabled || disabled),
      isHighlighted: state.context.highlightedId === id,
      isChecked: state.context.selectedOption?.value === props.value
    };
  }
  const popperStyles = getPlacementStyles({
    placement: state.context.currentPlacement
  });
  return {
    isOpen,
    highlightedOption,
    selectedOption,
    focus() {
      dom.getTriggerElement(state.context)?.focus();
    },
    open() {
      send("OPEN");
    },
    close() {
      send("CLOSE");
    },
    setSelectedOption(value) {
      validateOptionData(value);
      send({ type: "SELECT_OPTION", value });
    },
    setHighlightedOption(value) {
      validateOptionData(value);
      send({ type: "HIGHLIGHT_OPTION", value });
    },
    clearSelectedOption() {
      send({ type: "CLEAR_SELECTED" });
    },
    getOptionState,
    labelProps: normalize.label({
      dir: state.context.dir,
      id: dom.getLabelId(state.context),
      ...parts.label.attrs,
      "data-disabled": dataAttr(disabled),
      "data-invalid": dataAttr(invalid),
      "data-readonly": dataAttr(state.context.readOnly),
      htmlFor: dom.getHiddenSelectId(state.context),
      onClick() {
        if (disabled)
          return;
        dom.getTriggerElement(state.context)?.focus();
      }
    }),
    positionerProps: normalize.element({
      ...parts.positioner.attrs,
      id: dom.getPositionerId(state.context),
      style: popperStyles.floating
    }),
    triggerProps: normalize.button({
      id: dom.getTriggerId(state.context),
      disabled,
      dir: state.context.dir,
      type: "button",
      "aria-controls": dom.getContentId(state.context),
      "aria-expanded": isOpen,
      "data-state": isOpen ? "open" : "closed",
      "aria-haspopup": "listbox",
      "aria-labelledby": dom.getLabelId(state.context),
      ...parts.trigger.attrs,
      "data-disabled": dataAttr(disabled),
      "data-invalid": dataAttr(invalid),
      "aria-invalid": invalid,
      "data-readonly": dataAttr(state.context.readOnly),
      "data-placement": state.context.currentPlacement,
      "data-placeholder-shown": dataAttr(!state.context.hasSelectedOption),
      onPointerDown(event) {
        if (event.button || event.ctrlKey || !isInteractive)
          return;
        event.currentTarget.dataset.pointerType = event.pointerType;
        if (disabled || event.pointerType === "touch")
          return;
        send({ type: "TRIGGER_CLICK" });
      },
      onClick(event) {
        if (!isInteractive || event.button)
          return;
        if (event.currentTarget.dataset.pointerType === "touch") {
          send({ type: "TRIGGER_CLICK" });
        }
      },
      onFocus() {
        send("TRIGGER_FOCUS");
      },
      onBlur() {
        send("TRIGGER_BLUR");
      },
      onKeyDown(event) {
        if (!isInteractive)
          return;
        const keyMap = {
          ArrowUp() {
            send({ type: "ARROW_UP" });
          },
          ArrowDown() {
            send({ type: "ARROW_DOWN" });
          },
          ArrowLeft() {
            send({ type: "ARROW_LEFT" });
          },
          ArrowRight() {
            send({ type: "ARROW_RIGHT" });
          },
          Home() {
            send({ type: "HOME" });
          },
          Enter() {
            send({ type: "TRIGGER_CLICK" });
          },
          End() {
            send({ type: "END" });
          },
          Space(event2) {
            if (isTypingAhead) {
              send({ type: "TYPEAHEAD", key: event2.key });
            } else {
              send({ type: "TRIGGER_KEY" });
            }
          }
        };
        const exec = keyMap[getEventKey(event, state.context)];
        if (exec) {
          exec(event);
          event.preventDefault();
          return;
        }
        if (getByTypeahead2.isValidEvent(event)) {
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      }
    }),
    getOptionProps(props) {
      const { value, label, valueText } = props;
      const optionState = getOptionState(props);
      return normalize.element({
        id: dom.getOptionId(state.context, value),
        role: "option",
        ...parts.option.attrs,
        "data-label": label,
        "data-value": value,
        "data-valuetext": valueText ?? label,
        "aria-selected": optionState.isChecked,
        "data-state": optionState.isChecked ? "checked" : "unchecked",
        "data-highlighted": dataAttr(optionState.isHighlighted),
        "data-disabled": dataAttr(optionState.isDisabled),
        "aria-disabled": ariaAttr(optionState.isDisabled)
      });
    },
    getOptionGroupLabelProps(props) {
      const { htmlFor } = props;
      return normalize.element({
        id: dom.getOptionGroupId(state.context, htmlFor),
        role: "group",
        ...parts.optionGroupLabel.attrs
      });
    },
    getOptionGroupProps(props) {
      const { id } = props;
      return normalize.element({
        ...parts.optionGroup.attrs,
        "data-disabled": dataAttr(disabled),
        id: dom.getOptionGroupId(state.context, id),
        "aria-labelledby": dom.getOptionGroupLabelId(state.context, id)
      });
    },
    hiddenSelectProps: normalize.select({
      ...parts.hiddenSelect.attrs,
      name: state.context.name,
      form: state.context.form,
      disabled: !isInteractive,
      "aria-hidden": true,
      id: dom.getHiddenSelectId(state.context),
      defaultValue: state.context.selectedOption?.value,
      style: visuallyHiddenStyle,
      tabIndex: -1,
      // Some browser extensions will focus the hidden select.
      // Let's forward the focus to the trigger.
      onFocus() {
        dom.getTriggerElement(state.context)?.focus();
      },
      "aria-labelledby": dom.getLabelId(state.context)
    }),
    contentProps: normalize.element({
      hidden: !isOpen,
      dir: state.context.dir,
      id: dom.getContentId(state.context),
      role: "listbox",
      ...parts.content.attrs,
      "data-state": isOpen ? "open" : "closed",
      "aria-activedescendant": state.context.highlightedId || "",
      "aria-labelledby": dom.getLabelId(state.context),
      tabIndex: 0,
      onPointerMove(event) {
        if (!isInteractive)
          return;
        const option = dom.getClosestOption(event.target);
        if (!option || option.hasAttribute("data-disabled")) {
          send({ type: "POINTER_LEAVE" });
        } else {
          send({ type: "POINTER_MOVE", id: option.id, target: option });
        }
      },
      onPointerUp(event) {
        if (!isInteractive)
          return;
        const option = dom.getClosestOption(event.target);
        if (!option || option.hasAttribute("data-disabled"))
          return;
        send({ type: "OPTION_CLICK", src: "pointerup", id: option.id });
      },
      onPointerLeave() {
        send({ type: "POINTER_LEAVE" });
      },
      onClick(event) {
        if (!isInteractive)
          return;
        const option = dom.getClosestOption(event.target);
        if (!option || option.hasAttribute("data-disabled"))
          return;
        send({ type: "OPTION_CLICK", src: "click", id: option.id });
      },
      onKeyDown(event) {
        if (!isInteractive || !isSelfEvent(event))
          return;
        const keyMap = {
          ArrowUp() {
            send({ type: "ARROW_UP" });
          },
          ArrowDown() {
            send({ type: "ARROW_DOWN" });
          },
          Home() {
            send({ type: "HOME" });
          },
          End() {
            send({ type: "END" });
          },
          Tab(event2) {
            if (event2.shiftKey)
              return;
            send({ type: "TAB" });
          },
          Enter() {
            send({ type: "TRIGGER_KEY" });
          },
          Space(event2) {
            if (isTypingAhead) {
              send({ type: "TYPEAHEAD", key: event2.key });
            } else {
              keyMap.Enter?.(event2);
            }
          }
        };
        const exec = keyMap[getEventKey(event)];
        if (exec) {
          exec(event);
          event.preventDefault();
          return;
        }
        if (isEditableElement(event.target)) {
          return;
        }
        if (getByTypeahead2.isValidEvent(event)) {
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      }
    })
  };
}

// src/select.machine.ts
import { createMachine } from "@zag-js/core";
import { trackDismissableElement } from "@zag-js/dismissable";
import { getByTypeahead as getByTypeahead3, raf } from "@zag-js/dom-query";
import { setElementValue, trackFormControl } from "@zag-js/form-utils";
import { observeAttributes } from "@zag-js/mutation-observer";
import { getPlacement } from "@zag-js/popper";
import { proxyTabFocus } from "@zag-js/tabbable";
import { compact, json } from "@zag-js/utils";
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "select",
      context: {
        selectOnTab: false,
        selectedOption: null,
        highlightedOption: null,
        loop: false,
        closeOnSelect: true,
        ...ctx,
        initialSelectedOption: null,
        prevSelectedOption: null,
        prevHighlightedOption: null,
        typeahead: getByTypeahead3.defaultOptions,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        }
      },
      computed: {
        hasSelectedOption: (ctx2) => ctx2.selectedOption != null,
        isTypingAhead: (ctx2) => ctx2.typeahead.keysSoFar !== "",
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        selectedId: (ctx2) => ctx2.selectedOption ? dom.getOptionId(ctx2, ctx2.selectedOption.value) : null,
        highlightedId: (ctx2) => ctx2.highlightedOption ? dom.getOptionId(ctx2, ctx2.highlightedOption.value) : null,
        hasSelectedChanged: (ctx2) => ctx2.selectedOption?.value !== ctx2.prevSelectedOption?.value,
        hasHighlightedChanged: (ctx2) => ctx2.highlightedOption?.value !== ctx2.prevHighlightedOption?.value
      },
      initial: "idle",
      watch: {
        selectedOption: ["syncSelectValue", "dispatchChangeEvent"]
      },
      on: {
        HIGHLIGHT_OPTION: {
          actions: ["setHighlightedOption", "invokeOnHighlight"]
        },
        SELECT_OPTION: {
          actions: ["setSelectedOption", "invokeOnSelect"]
        },
        CLEAR_SELECTED: {
          actions: ["clearSelectedOption", "invokeOnSelect"]
        }
      },
      entry: ["setInitialSelectedOption"],
      activities: ["trackFormControlState"],
      states: {
        idle: {
          tags: ["closed"],
          on: {
            TRIGGER_CLICK: {
              target: "open"
            },
            TRIGGER_FOCUS: {
              target: "focused"
            },
            OPEN: {
              target: "open"
            }
          }
        },
        focused: {
          tags: ["closed"],
          entry: ["focusTrigger", "clearHighlightedOption"],
          on: {
            TRIGGER_CLICK: {
              target: "open"
            },
            TRIGGER_BLUR: {
              target: "idle",
              actions: ["clearHighlightedOption"]
            },
            TRIGGER_KEY: {
              target: "open"
            },
            ARROW_UP: {
              target: "open",
              actions: ["highlightLastOption", "invokeOnHighlight"]
            },
            ARROW_DOWN: {
              target: "open",
              actions: ["highlightFirstOption", "invokeOnHighlight"]
            },
            ARROW_LEFT: [
              {
                guard: "hasSelectedOption",
                actions: ["selectPreviousOption", "invokeOnSelect"]
              },
              {
                actions: ["selectLastOption", "invokeOnSelect"]
              }
            ],
            ARROW_RIGHT: [
              {
                guard: "hasSelectedOption",
                actions: ["selectNextOption", "invokeOnSelect"]
              },
              {
                actions: ["selectFirstOption", "invokeOnSelect"]
              }
            ],
            HOME: {
              actions: ["selectFirstOption", "invokeOnSelect"]
            },
            END: {
              actions: ["selectLastOption", "invokeOnSelect"]
            },
            TYPEAHEAD: {
              actions: ["selectMatchingOption", "invokeOnSelect"]
            },
            OPEN: {
              target: "open"
            }
          }
        },
        open: {
          tags: ["open"],
          entry: ["focusContent", "highlightSelectedOption", "invokeOnOpen"],
          exit: ["scrollContentToTop"],
          activities: ["trackInteractOutside", "computePlacement", "scrollToHighlightedOption", "proxyTabFocus"],
          on: {
            CLOSE: {
              target: "focused",
              actions: ["invokeOnClose"]
            },
            TRIGGER_CLICK: {
              target: "focused",
              actions: ["invokeOnClose"]
            },
            OPTION_CLICK: [
              {
                target: "focused",
                actions: ["selectHighlightedOption", "invokeOnSelect", "invokeOnClose"],
                guard: "closeOnSelect"
              },
              {
                actions: ["selectHighlightedOption", "invokeOnSelect"]
              }
            ],
            TRIGGER_KEY: [
              {
                target: "focused",
                actions: ["selectHighlightedOption", "invokeOnSelect", "invokeOnClose"],
                guard: "closeOnSelect"
              },
              {
                actions: ["selectHighlightedOption", "invokeOnSelect"]
              }
            ],
            BLUR: {
              target: "focused",
              actions: ["invokeOnClose"]
            },
            HOME: {
              actions: ["highlightFirstOption", "invokeOnHighlight"]
            },
            END: {
              actions: ["highlightLastOption", "invokeOnHighlight"]
            },
            ARROW_DOWN: [
              {
                guard: "hasHighlightedOption",
                actions: ["highlightNextOption", "invokeOnHighlight"]
              },
              {
                actions: ["highlightFirstOption", "invokeOnHighlight"]
              }
            ],
            ARROW_UP: [
              {
                guard: "hasHighlightedOption",
                actions: ["highlightPreviousOption", "invokeOnHighlight"]
              },
              {
                actions: ["highlightLastOption", "invokeOnHighlight"]
              }
            ],
            TYPEAHEAD: {
              actions: ["highlightMatchingOption", "invokeOnHighlight"]
            },
            POINTER_MOVE: {
              actions: ["highlightOption", "invokeOnHighlight"]
            },
            POINTER_LEAVE: {
              actions: ["clearHighlightedOption"]
            },
            TAB: [
              {
                target: "idle",
                actions: ["selectHighlightedOption", "invokeOnClose", "invokeOnSelect", "clearHighlightedOption"],
                guard: "selectOnTab"
              },
              {
                target: "idle",
                actions: ["invokeOnClose", "clearHighlightedOption"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        hasHighlightedOption: (ctx2) => ctx2.highlightedId != null,
        selectOnTab: (ctx2) => !!ctx2.selectOnTab,
        hasSelectedOption: (ctx2) => ctx2.hasSelectedOption,
        closeOnSelect: (ctx2) => !!ctx2.closeOnSelect
      },
      activities: {
        proxyTabFocus(ctx2) {
          return proxyTabFocus(dom.getContentElement(ctx2), {
            triggerElement: dom.getTriggerElement(ctx2),
            onFocus(el) {
              raf(() => el.focus({ preventScroll: true }));
            }
          });
        },
        trackFormControlState(ctx2) {
          return trackFormControl(dom.getHiddenSelectElement(ctx2), {
            onFieldsetDisabled() {
              ctx2.disabled = true;
            },
            onFormReset() {
              ctx2.prevSelectedOption = ctx2.selectedOption;
              ctx2.selectedOption = ctx2.initialSelectedOption;
            }
          });
        },
        trackInteractOutside(ctx2, _evt, { send }) {
          let focusable = false;
          return trackDismissableElement(dom.getContentElement(ctx2), {
            exclude: [dom.getTriggerElement(ctx2)],
            onInteractOutside(event) {
              focusable = event.detail.focusable;
              ctx2.onInteractOutside?.(event);
            },
            onDismiss() {
              send({ type: "BLUR", src: "interact-outside", focusable });
            }
          });
        },
        computePlacement(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          return getPlacement(dom.getTriggerElement(ctx2), dom.getPositionerElement(ctx2), {
            ...ctx2.positioning,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        scrollToHighlightedOption(ctx2, _evt, { getState }) {
          const exec = () => {
            const state = getState();
            if (state.event.type === "POINTER_MOVE")
              return;
            const option = dom.getHighlightedOption(ctx2);
            option?.scrollIntoView({ block: "nearest" });
          };
          raf(() => {
            exec();
          });
          return observeAttributes(dom.getContentElement(ctx2), ["aria-activedescendant"], exec);
        }
      },
      actions: {
        setInitialSelectedOption(ctx2) {
          ctx2.initialSelectedOption = ctx2.selectedOption;
        },
        highlightPreviousOption(ctx2) {
          if (!ctx2.highlightedId)
            return;
          const option = dom.getPreviousOption(ctx2, ctx2.highlightedId);
          highlightOption(ctx2, option);
        },
        highlightNextOption(ctx2) {
          if (!ctx2.highlightedId)
            return;
          const option = dom.getNextOption(ctx2, ctx2.highlightedId);
          highlightOption(ctx2, option);
        },
        highlightFirstOption(ctx2) {
          const option = dom.getFirstOption(ctx2);
          highlightOption(ctx2, option);
        },
        highlightLastOption(ctx2) {
          const option = dom.getLastOption(ctx2);
          highlightOption(ctx2, option);
        },
        focusContent(ctx2) {
          raf(() => {
            dom.getContentElement(ctx2)?.focus({ preventScroll: true });
          });
        },
        focusTrigger(ctx2, evt) {
          if (evt.focusable)
            return;
          raf(() => {
            dom.getTriggerElement(ctx2)?.focus({ preventScroll: true });
          });
        },
        selectHighlightedOption(ctx2, evt) {
          const id = evt.id ?? ctx2.highlightedId;
          if (!id)
            return;
          const option = dom.getById(ctx2, id);
          selectOption(ctx2, option);
        },
        selectFirstOption(ctx2) {
          const option = dom.getFirstOption(ctx2);
          selectOption(ctx2, option);
        },
        selectLastOption(ctx2) {
          const option = dom.getLastOption(ctx2);
          selectOption(ctx2, option);
        },
        selectNextOption(ctx2) {
          if (!ctx2.selectedId)
            return;
          const option = dom.getNextOption(ctx2, ctx2.selectedId);
          selectOption(ctx2, option);
        },
        selectPreviousOption(ctx2) {
          if (!ctx2.selectedId)
            return;
          const option = dom.getPreviousOption(ctx2, ctx2.selectedId);
          selectOption(ctx2, option);
        },
        highlightSelectedOption(ctx2) {
          if (!ctx2.selectedOption)
            return;
          ctx2.prevHighlightedOption = ctx2.highlightedOption;
          ctx2.highlightedOption = ctx2.selectedOption;
        },
        highlightOption(ctx2, evt) {
          const option = evt.target ?? dom.getById(ctx2, evt.id);
          highlightOption(ctx2, option);
        },
        highlightMatchingOption(ctx2, evt) {
          const option = dom.getMatchingOption(ctx2, evt.key, ctx2.highlightedId);
          highlightOption(ctx2, option);
        },
        selectMatchingOption(ctx2, evt) {
          const option = dom.getMatchingOption(ctx2, evt.key, ctx2.selectedId);
          selectOption(ctx2, option);
        },
        setHighlightedOption(ctx2, evt) {
          if (!evt.value)
            return;
          ctx2.prevHighlightedOption = ctx2.highlightedOption;
          ctx2.highlightedOption = evt.value;
        },
        clearHighlightedOption(ctx2) {
          ctx2.highlightedOption = null;
        },
        setSelectedOption(ctx2, evt) {
          if (!evt.value)
            return;
          ctx2.prevSelectedOption = ctx2.selectedOption;
          ctx2.selectedOption = evt.value;
        },
        clearSelectedOption(ctx2) {
          ctx2.selectedOption = null;
        },
        scrollContentToTop(ctx2) {
          dom.getContentElement(ctx2)?.scrollTo(0, 0);
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpen?.();
        },
        invokeOnClose(ctx2) {
          ctx2.onClose?.();
        },
        invokeOnHighlight(ctx2) {
          if (!ctx2.hasHighlightedChanged)
            return;
          ctx2.onHighlight?.(json(ctx2.highlightedOption));
        },
        invokeOnSelect(ctx2) {
          if (!ctx2.hasSelectedChanged)
            return;
          ctx2.onChange?.(json(ctx2.selectedOption));
        },
        syncSelectValue(ctx2) {
          const selectedOption = ctx2.selectedOption;
          const node = dom.getHiddenSelectElement(ctx2);
          if (!node || !selectedOption)
            return;
          setElementValue(node, selectedOption.value, { type: "HTMLSelectElement" });
        },
        dispatchChangeEvent(ctx2) {
          const node = dom.getHiddenSelectElement(ctx2);
          if (!node)
            return;
          const win = dom.getWin(ctx2);
          const changeEvent = new win.Event("change", { bubbles: true });
          node.dispatchEvent(changeEvent);
        }
      }
    }
  );
}
function highlightOption(ctx, option) {
  if (!option)
    return;
  ctx.prevHighlightedOption = ctx.highlightedOption;
  ctx.highlightedOption = dom.getOptionDetails(option);
}
function selectOption(ctx, option) {
  if (!option)
    return;
  ctx.prevSelectedOption = ctx.selectedOption;
  ctx.selectedOption = dom.getOptionDetails(option);
}
export {
  anatomy,
  connect,
  machine
};
//# sourceMappingURL=index.mjs.map