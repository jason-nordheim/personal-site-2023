"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  anatomy: () => anatomy,
  connect: () => connect,
  machine: () => machine
});
module.exports = __toCommonJS(src_exports);

// src/rating-group.anatomy.ts
var import_anatomy = require("@zag-js/anatomy");
var anatomy = (0, import_anatomy.createAnatomy)("rating-group").parts("root", "hiddenInput", "label", "rating", "control");
var parts = anatomy.build();

// src/rating-group.connect.ts
var import_dom_event = require("@zag-js/dom-event");
var import_dom_query2 = require("@zag-js/dom-query");

// src/rating-group.dom.ts
var import_dom_query = require("@zag-js/dom-query");
var import_form_utils = require("@zag-js/form-utils");
var dom = (0, import_dom_query.createScope)({
  getRootId: (ctx) => ctx.ids?.root ?? `rating:${ctx.id}`,
  getLabelId: (ctx) => ctx.ids?.label ?? `rating:${ctx.id}:label`,
  getHiddenInputId: (ctx) => ctx.ids?.hiddenInput ?? `rating:${ctx.id}:input`,
  getControlId: (ctx) => ctx.ids?.control ?? `rating:${ctx.id}:control`,
  getRatingId: (ctx, id) => ctx.ids?.rating?.(id) ?? `rating:${ctx.id}:star:${id}`,
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getControlEl: (ctx) => dom.getById(ctx, dom.getControlId(ctx)),
  getRadioEl: (ctx) => dom.getControlEl(ctx)?.querySelector(`[role=radio][aria-posinset='${Math.ceil(ctx.value)}']`),
  getActiveEl: (ctx) => dom.getRootNode(ctx).activeElement,
  getHiddenInputEl: (ctx) => dom.getById(ctx, dom.getHiddenInputId(ctx)),
  dispatchChangeEvent: (ctx) => {
    const inputEl = dom.getHiddenInputEl(ctx);
    if (!inputEl)
      return;
    (0, import_form_utils.dispatchInputValueEvent)(inputEl, { value: ctx.value });
  }
});

// src/rating-group.connect.ts
function connect(state, send, normalize) {
  const isInteractive = state.context.isInteractive;
  const value = state.context.value;
  const hoveredValue = state.context.hoveredValue;
  const isDisabled = state.context.disabled;
  const translations = state.context.translations;
  const api = {
    setValue(value2) {
      send({ type: "SET_VALUE", value: value2 });
    },
    clearValue() {
      send("CLEAR_VALUE");
    },
    isHovering: state.context.isHovering,
    value,
    hoveredValue,
    size: state.context.max,
    sizeArray: Array.from({ length: state.context.max }).map((_, index) => index + 1),
    getRatingState(props) {
      const value2 = state.context.isHovering ? state.context.hoveredValue : state.context.value;
      const isEqual = Math.ceil(value2) === props.index;
      const isHighlighted = props.index <= value2 || isEqual;
      const isHalf = isEqual && Math.abs(value2 - props.index) === 0.5;
      return {
        isEqual,
        isValueEmpty: state.context.value === -1,
        isHighlighted,
        isHalf,
        isChecked: isEqual || state.context.value === -1 && props.index === 1
      };
    },
    rootProps: normalize.element({
      dir: state.context.dir,
      ...parts.root.attrs,
      id: dom.getRootId(state.context)
    }),
    hiddenInputProps: normalize.input({
      ...parts.hiddenInput.attrs,
      name: state.context.name,
      form: state.context.form,
      type: "text",
      hidden: true,
      id: dom.getHiddenInputId(state.context),
      defaultValue: state.context.value
    }),
    labelProps: normalize.element({
      ...parts.label.attrs,
      id: dom.getLabelId(state.context),
      "data-disabled": (0, import_dom_query2.dataAttr)(isDisabled)
    }),
    controlProps: normalize.element({
      id: dom.getControlId(state.context),
      ...parts.control.attrs,
      role: "radiogroup",
      "aria-orientation": "horizontal",
      "aria-labelledby": dom.getLabelId(state.context),
      tabIndex: state.context.readOnly ? 0 : -1,
      "data-disabled": (0, import_dom_query2.dataAttr)(isDisabled),
      onPointerMove(event) {
        if (!isInteractive || event.pointerType === "touch")
          return;
        send("GROUP_POINTER_OVER");
      },
      onPointerLeave(event) {
        if (!isInteractive || event.pointerType === "touch")
          return;
        send("GROUP_POINTER_LEAVE");
      }
    }),
    getRatingProps(props) {
      const { index } = props;
      const { isHalf, isHighlighted, isChecked } = api.getRatingState(props);
      const valueText = translations.ratingValueText(index);
      return normalize.element({
        ...parts.rating.attrs,
        id: dom.getRatingId(state.context, index.toString()),
        role: "radio",
        tabIndex: isDisabled ? void 0 : isChecked ? 0 : -1,
        "aria-roledescription": "rating",
        "aria-label": valueText,
        "aria-disabled": isDisabled,
        "data-disabled": (0, import_dom_query2.dataAttr)(isDisabled),
        "aria-readonly": (0, import_dom_query2.ariaAttr)(state.context.readOnly),
        "data-readonly": (0, import_dom_query2.dataAttr)(state.context.readOnly),
        "aria-setsize": state.context.max,
        "aria-checked": isChecked,
        "data-checked": (0, import_dom_query2.dataAttr)(isChecked),
        "aria-posinset": index,
        "data-highlighted": (0, import_dom_query2.dataAttr)(isHighlighted),
        "data-half": (0, import_dom_query2.dataAttr)(isHalf),
        onPointerDown(event) {
          if (!isInteractive)
            return;
          const evt = (0, import_dom_event.getNativeEvent)(event);
          if ((0, import_dom_event.isLeftClick)(evt)) {
            event.preventDefault();
          }
        },
        onPointerMove(event) {
          if (!isInteractive)
            return;
          const point = (0, import_dom_event.getEventPoint)((0, import_dom_event.getNativeEvent)(event));
          const relativePoint = (0, import_dom_event.getRelativePoint)(point, event.currentTarget);
          const percentX = relativePoint.getPercentValue({
            orientation: "horizontal",
            dir: state.context.dir
          });
          const isMidway = percentX < 0.5;
          send({ type: "POINTER_OVER", index, isMidway });
        },
        onKeyDown(event) {
          if (!isInteractive)
            return;
          const keyMap = {
            ArrowLeft() {
              send("ARROW_LEFT");
            },
            ArrowRight() {
              send("ARROW_RIGHT");
            },
            ArrowUp() {
              send("ARROW_LEFT");
            },
            ArrowDown() {
              send("ARROW_RIGHT");
            },
            Space() {
              send({ type: "SPACE", value: index });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = (0, import_dom_event.getEventKey)(event, state.context);
          const exec = keyMap[key];
          if (exec) {
            event.preventDefault();
            exec(event);
          }
        },
        onClick() {
          if (!isInteractive)
            return;
          send({ type: "CLICK", value: index });
        },
        onFocus() {
          if (!isInteractive)
            return;
          send("FOCUS");
        },
        onBlur() {
          if (!isInteractive)
            return;
          send("BLUR");
        }
      });
    }
  };
  return api;
}

// src/rating-group.machine.ts
var import_core = require("@zag-js/core");
var import_dom_query3 = require("@zag-js/dom-query");
var import_form_utils2 = require("@zag-js/form-utils");
var import_utils = require("@zag-js/utils");
function machine(userContext) {
  const ctx = (0, import_utils.compact)(userContext);
  return (0, import_core.createMachine)(
    {
      id: "rating",
      initial: "idle",
      context: {
        name: "rating",
        max: 5,
        dir: "ltr",
        value: -1,
        hoveredValue: -1,
        disabled: false,
        readOnly: false,
        ...ctx,
        translations: {
          ratingValueText: (index) => `${index} stars`,
          ...ctx.translations
        }
      },
      created: ["roundValueIfNeeded"],
      watch: {
        allowHalf: ["roundValueIfNeeded"],
        value: ["invokeOnChange", "dispatchChangeEvent"]
      },
      computed: {
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        isHovering: (ctx2) => ctx2.hoveredValue > -1
      },
      activities: ["trackFormControlState"],
      on: {
        SET_VALUE: {
          actions: ["setValue"]
        },
        CLEAR_VALUE: {
          actions: ["clearValue"]
        }
      },
      states: {
        idle: {
          entry: "clearHoveredValue",
          on: {
            GROUP_POINTER_OVER: "hover",
            FOCUS: "focus",
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            }
          }
        },
        focus: {
          on: {
            POINTER_OVER: {
              actions: "setHoveredValue"
            },
            GROUP_POINTER_LEAVE: {
              actions: "clearHoveredValue"
            },
            BLUR: "idle",
            SPACE: {
              guard: "isValueEmpty",
              actions: ["setValue"]
            },
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            },
            ARROW_LEFT: {
              actions: ["setPrevValue", "focusActiveRadio"]
            },
            ARROW_RIGHT: {
              actions: ["setNextValue", "focusActiveRadio"]
            },
            HOME: {
              actions: ["setValueToMin", "focusActiveRadio"]
            },
            END: {
              actions: ["setValueToMax", "focusActiveRadio"]
            }
          }
        },
        hover: {
          on: {
            POINTER_OVER: {
              actions: "setHoveredValue"
            },
            GROUP_POINTER_LEAVE: [
              {
                guard: "isRadioFocused",
                target: "focus",
                actions: "clearHoveredValue"
              },
              {
                target: "idle",
                actions: "clearHoveredValue"
              }
            ],
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            }
          }
        }
      }
    },
    {
      guards: {
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        isHoveredValueEmpty: (ctx2) => ctx2.hoveredValue === -1,
        isValueEmpty: (ctx2) => ctx2.value <= 0,
        isRadioFocused: (ctx2) => !!dom.getControlEl(ctx2)?.contains(dom.getActiveEl(ctx2))
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return (0, import_form_utils2.trackFormControl)(dom.getHiddenInputEl(ctx2), {
            onFieldsetDisabled() {
              ctx2.disabled = true;
            },
            onFormReset() {
              ctx2.value = initialContext.value;
            }
          });
        }
      },
      actions: {
        clearHoveredValue(ctx2) {
          ctx2.hoveredValue = -1;
        },
        focusActiveRadio(ctx2) {
          (0, import_dom_query3.raf)(() => dom.getRadioEl(ctx2)?.focus());
        },
        setPrevValue(ctx2) {
          const factor = ctx2.allowHalf ? 0.5 : 1;
          ctx2.value = Math.max(0, ctx2.value - factor);
        },
        setNextValue(ctx2) {
          const factor = ctx2.allowHalf ? 0.5 : 1;
          const value = ctx2.value === -1 ? 0 : ctx2.value;
          ctx2.value = Math.min(ctx2.max, value + factor);
        },
        setValueToMin(ctx2) {
          ctx2.value = 1;
        },
        setValueToMax(ctx2) {
          ctx2.value = ctx2.max;
        },
        setValue(ctx2, evt) {
          ctx2.value = ctx2.hoveredValue === -1 ? evt.value : ctx2.hoveredValue;
        },
        clearValue(ctx2) {
          ctx2.value = -1;
        },
        setHoveredValue(ctx2, evt) {
          const half = ctx2.allowHalf && evt.isMidway;
          const factor = half ? 0.5 : 0;
          let value = evt.index - factor;
          ctx2.hoveredValue = value;
        },
        dispatchChangeEvent(ctx2) {
          dom.dispatchChangeEvent(ctx2);
        },
        invokeOnChange(ctx2) {
          ctx2.onChange?.({ value: ctx2.value });
        },
        invokeOnHover(ctx2) {
          ctx2.onHover?.({ value: ctx2.hoveredValue });
        },
        roundValueIfNeeded(ctx2) {
          if (!ctx2.allowHalf) {
            ctx2.value = Math.round(ctx2.value);
          }
        }
      }
    }
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  anatomy,
  connect,
  machine
});
//# sourceMappingURL=index.js.map