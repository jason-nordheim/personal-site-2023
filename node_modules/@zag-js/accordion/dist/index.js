"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  anatomy: () => anatomy,
  connect: () => connect,
  machine: () => machine
});
module.exports = __toCommonJS(src_exports);

// src/accordion.anatomy.ts
var import_anatomy = require("@zag-js/anatomy");
var anatomy = (0, import_anatomy.createAnatomy)("accordion").parts("root", "item", "trigger", "content");
var parts = anatomy.build();

// src/accordion.connect.ts
var import_dom_event = require("@zag-js/dom-event");
var import_dom_query2 = require("@zag-js/dom-query");

// src/accordion.dom.ts
var import_dom_query = require("@zag-js/dom-query");
var import_utils = require("@zag-js/utils");
var dom = (0, import_dom_query.createScope)({
  getRootId: (ctx) => ctx.ids?.root ?? `accordion:${ctx.id}`,
  getItemId: (ctx, value) => ctx.ids?.item?.(value) ?? `accordion:${ctx.id}:item:${value}`,
  getContentId: (ctx, value) => ctx.ids?.content?.(value) ?? `accordion:${ctx.id}:content:${value}`,
  getTriggerId: (ctx, value) => ctx.ids?.trigger?.(value) ?? `accordion:${ctx.id}:trigger:${value}`,
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getTriggers: (ctx) => {
    const ownerId = CSS.escape(dom.getRootId(ctx));
    const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`;
    return (0, import_dom_query.queryAll)(dom.getRootEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => (0, import_utils.first)(dom.getTriggers(ctx)),
  getLastTriggerEl: (ctx) => (0, import_utils.last)(dom.getTriggers(ctx)),
  getNextTriggerEl: (ctx, id) => (0, import_dom_query.nextById)(dom.getTriggers(ctx), dom.getTriggerId(ctx, id)),
  getPrevTriggerEl: (ctx, id) => (0, import_dom_query.prevById)(dom.getTriggers(ctx), dom.getTriggerId(ctx, id))
});

// src/accordion.connect.ts
function connect(state, send, normalize) {
  const focusedValue = state.context.focusedValue;
  const value = state.context.value;
  const multiple = state.context.multiple;
  function setValue(value2) {
    let nextValue = value2;
    if (multiple && !Array.isArray(nextValue)) {
      nextValue = [nextValue];
    }
    send({ type: "VALUE.SET", value: nextValue });
  }
  function getItemState(props) {
    return {
      isOpen: Array.isArray(value) ? value.includes(props.value) : props.value === value,
      isFocused: focusedValue === props.value,
      isDisabled: Boolean(props.disabled ?? state.context.disabled)
    };
  }
  return {
    focusedValue,
    value,
    setValue,
    getItemState,
    rootProps: normalize.element({
      ...parts.root.attrs,
      id: dom.getRootId(state.context),
      "data-orientation": state.context.orientation
    }),
    getItemProps(props) {
      const { isOpen, isFocused, isDisabled } = getItemState(props);
      return normalize.element({
        ...parts.item.attrs,
        id: dom.getItemId(state.context, props.value),
        "data-state": isOpen ? "open" : "closed",
        "data-focus": (0, import_dom_query2.dataAttr)(isFocused),
        "data-disabled": (0, import_dom_query2.dataAttr)(isDisabled),
        "data-orientation": state.context.orientation
      });
    },
    getContentProps(props) {
      const { isOpen, isFocused, isDisabled } = getItemState(props);
      return normalize.element({
        ...parts.content.attrs,
        role: "region",
        id: dom.getContentId(state.context, props.value),
        "aria-labelledby": dom.getTriggerId(state.context, props.value),
        hidden: !isOpen,
        "data-state": isOpen ? "open" : "closed",
        "data-disabled": (0, import_dom_query2.dataAttr)(isDisabled),
        "data-focus": (0, import_dom_query2.dataAttr)(isFocused),
        "data-orientation": state.context.orientation
      });
    },
    getTriggerProps(props) {
      const { value: value2 } = props;
      const itemState = getItemState(props);
      return normalize.button({
        ...parts.trigger.attrs,
        type: "button",
        id: dom.getTriggerId(state.context, value2),
        "aria-controls": dom.getContentId(state.context, value2),
        "aria-expanded": itemState.isOpen,
        disabled: itemState.isDisabled,
        "data-orientation": state.context.orientation,
        "aria-disabled": itemState.isDisabled,
        "data-state": itemState.isOpen ? "open" : "closed",
        "data-ownedby": dom.getRootId(state.context),
        onFocus() {
          if (itemState.isDisabled)
            return;
          send({ type: "TRIGGER.FOCUS", value: value2 });
        },
        onBlur() {
          if (itemState.isDisabled)
            return;
          send("TRIGGER.BLUR");
        },
        onClick(event) {
          if (itemState.isDisabled)
            return;
          if ((0, import_dom_query2.isSafari)()) {
            event.currentTarget.focus();
          }
          send({ type: "TRIGGER.CLICK", value: value2 });
        },
        onKeyDown(event) {
          if (itemState.isDisabled)
            return;
          const keyMap = {
            ArrowDown() {
              if (state.context.isHorizontal)
                return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowUp() {
              if (state.context.isHorizontal)
                return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            ArrowRight() {
              if (!state.context.isHorizontal)
                return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowLeft() {
              if (!state.context.isHorizontal)
                return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            Home() {
              send({ type: "GOTO.FIRST", value: value2 });
            },
            End() {
              send({ type: "GOTO.LAST", value: value2 });
            }
          };
          const key = (0, import_dom_event.getEventKey)(event, {
            dir: state.context.dir,
            orientation: state.context.orientation
          });
          const exec = keyMap[key];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        }
      });
    }
  };
}

// src/accordion.machine.ts
var import_core = require("@zag-js/core");
var import_utils2 = require("@zag-js/utils");
var { and, not } = import_core.guards;
var valueMismatchMessage = `[accordion/invalid-value] Expected value for multiple accordion to be an 'array' but received 'string'. Value will be coarsed to 'array'`;
function machine(userContext) {
  const ctx = (0, import_utils2.compact)(userContext);
  return (0, import_core.createMachine)(
    {
      id: "accordion",
      initial: "idle",
      context: {
        focusedValue: null,
        value: null,
        collapsible: false,
        multiple: false,
        orientation: "vertical",
        ...ctx
      },
      watch: {
        value: "sanitizeValue",
        multiple: "sanitizeValue"
      },
      created: "sanitizeValue",
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal"
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue", "invokeOnChange"]
        }
      },
      states: {
        idle: {
          on: {
            "TRIGGER.FOCUS": {
              target: "focused",
              actions: "setFocusedValue"
            }
          }
        },
        focused: {
          on: {
            "GOTO.NEXT": {
              actions: "focusNext"
            },
            "GOTO.PREV": {
              actions: "focusPrev"
            },
            "TRIGGER.CLICK": [
              {
                guard: and("isExpanded", "canToggle"),
                actions: ["collapse", "invokeOnChange"]
              },
              {
                guard: not("isExpanded"),
                actions: ["expand", "invokeOnChange"]
              }
            ],
            "GOTO.FIRST": {
              actions: "focusFirst"
            },
            "GOTO.LAST": {
              actions: "focusLast"
            },
            "TRIGGER.BLUR": {
              target: "idle",
              actions: "clearFocusedValue"
            }
          }
        }
      }
    },
    {
      guards: {
        canToggle: (ctx2) => !!ctx2.collapsible || !!ctx2.multiple,
        isExpanded: (ctx2, evt) => {
          if (ctx2.multiple && Array.isArray(ctx2.value)) {
            return ctx2.value.includes(evt.value);
          }
          return ctx2.value === evt.value;
        }
      },
      actions: {
        invokeOnChange(ctx2) {
          ctx2.onChange?.({ value: ctx2.value });
        },
        collapse(ctx2, evt) {
          ctx2.value = ctx2.multiple ? (0, import_utils2.remove)((0, import_utils2.toArray)(ctx2.value), evt.value) : null;
        },
        expand(ctx2, evt) {
          ctx2.value = ctx2.multiple ? (0, import_utils2.add)((0, import_utils2.toArray)(ctx2.value), evt.value) : evt.value;
        },
        focusFirst(ctx2) {
          dom.getFirstTriggerEl(ctx2)?.focus();
        },
        focusLast(ctx2) {
          dom.getLastTriggerEl(ctx2)?.focus();
        },
        focusNext(ctx2) {
          if (!ctx2.focusedValue)
            return;
          const el = dom.getNextTriggerEl(ctx2, ctx2.focusedValue);
          el?.focus();
        },
        focusPrev(ctx2) {
          if (!ctx2.focusedValue)
            return;
          const el = dom.getPrevTriggerEl(ctx2, ctx2.focusedValue);
          el?.focus();
        },
        setFocusedValue(ctx2, evt) {
          ctx2.focusedValue = evt.value;
        },
        clearFocusedValue(ctx2) {
          ctx2.focusedValue = null;
        },
        setValue(ctx2, evt) {
          ctx2.value = evt.value;
        },
        sanitizeValue(ctx2) {
          if (ctx2.multiple && (0, import_utils2.isString)(ctx2.value)) {
            (0, import_utils2.warn)(valueMismatchMessage);
            ctx2.value = [ctx2.value];
          } else if (!ctx2.multiple && Array.isArray(ctx2.value) && ctx2.value.length > 0) {
            ctx2.value = ctx2.value[0];
          }
        }
      }
    }
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  anatomy,
  connect,
  machine
});
//# sourceMappingURL=index.js.map