// src/accordion.anatomy.ts
import { createAnatomy } from "@zag-js/anatomy";
var anatomy = createAnatomy("accordion").parts("root", "item", "trigger", "content");
var parts = anatomy.build();

// src/accordion.connect.ts
import { getEventKey } from "@zag-js/dom-event";
import { dataAttr, isSafari } from "@zag-js/dom-query";

// src/accordion.dom.ts
import { nextById, prevById, queryAll, createScope } from "@zag-js/dom-query";
import { first, last } from "@zag-js/utils";
var dom = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `accordion:${ctx.id}`,
  getItemId: (ctx, value) => ctx.ids?.item?.(value) ?? `accordion:${ctx.id}:item:${value}`,
  getContentId: (ctx, value) => ctx.ids?.content?.(value) ?? `accordion:${ctx.id}:content:${value}`,
  getTriggerId: (ctx, value) => ctx.ids?.trigger?.(value) ?? `accordion:${ctx.id}:trigger:${value}`,
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getTriggers: (ctx) => {
    const ownerId = CSS.escape(dom.getRootId(ctx));
    const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom.getRootEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => first(dom.getTriggers(ctx)),
  getLastTriggerEl: (ctx) => last(dom.getTriggers(ctx)),
  getNextTriggerEl: (ctx, id) => nextById(dom.getTriggers(ctx), dom.getTriggerId(ctx, id)),
  getPrevTriggerEl: (ctx, id) => prevById(dom.getTriggers(ctx), dom.getTriggerId(ctx, id))
});

// src/accordion.connect.ts
function connect(state, send, normalize) {
  const focusedValue = state.context.focusedValue;
  const value = state.context.value;
  const multiple = state.context.multiple;
  function setValue(value2) {
    let nextValue = value2;
    if (multiple && !Array.isArray(nextValue)) {
      nextValue = [nextValue];
    }
    send({ type: "VALUE.SET", value: nextValue });
  }
  function getItemState(props) {
    return {
      isOpen: Array.isArray(value) ? value.includes(props.value) : props.value === value,
      isFocused: focusedValue === props.value,
      isDisabled: Boolean(props.disabled ?? state.context.disabled)
    };
  }
  return {
    focusedValue,
    value,
    setValue,
    getItemState,
    rootProps: normalize.element({
      ...parts.root.attrs,
      id: dom.getRootId(state.context),
      "data-orientation": state.context.orientation
    }),
    getItemProps(props) {
      const { isOpen, isFocused, isDisabled } = getItemState(props);
      return normalize.element({
        ...parts.item.attrs,
        id: dom.getItemId(state.context, props.value),
        "data-state": isOpen ? "open" : "closed",
        "data-focus": dataAttr(isFocused),
        "data-disabled": dataAttr(isDisabled),
        "data-orientation": state.context.orientation
      });
    },
    getContentProps(props) {
      const { isOpen, isFocused, isDisabled } = getItemState(props);
      return normalize.element({
        ...parts.content.attrs,
        role: "region",
        id: dom.getContentId(state.context, props.value),
        "aria-labelledby": dom.getTriggerId(state.context, props.value),
        hidden: !isOpen,
        "data-state": isOpen ? "open" : "closed",
        "data-disabled": dataAttr(isDisabled),
        "data-focus": dataAttr(isFocused),
        "data-orientation": state.context.orientation
      });
    },
    getTriggerProps(props) {
      const { value: value2 } = props;
      const itemState = getItemState(props);
      return normalize.button({
        ...parts.trigger.attrs,
        type: "button",
        id: dom.getTriggerId(state.context, value2),
        "aria-controls": dom.getContentId(state.context, value2),
        "aria-expanded": itemState.isOpen,
        disabled: itemState.isDisabled,
        "data-orientation": state.context.orientation,
        "aria-disabled": itemState.isDisabled,
        "data-state": itemState.isOpen ? "open" : "closed",
        "data-ownedby": dom.getRootId(state.context),
        onFocus() {
          if (itemState.isDisabled)
            return;
          send({ type: "TRIGGER.FOCUS", value: value2 });
        },
        onBlur() {
          if (itemState.isDisabled)
            return;
          send("TRIGGER.BLUR");
        },
        onClick(event) {
          if (itemState.isDisabled)
            return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TRIGGER.CLICK", value: value2 });
        },
        onKeyDown(event) {
          if (itemState.isDisabled)
            return;
          const keyMap = {
            ArrowDown() {
              if (state.context.isHorizontal)
                return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowUp() {
              if (state.context.isHorizontal)
                return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            ArrowRight() {
              if (!state.context.isHorizontal)
                return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowLeft() {
              if (!state.context.isHorizontal)
                return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            Home() {
              send({ type: "GOTO.FIRST", value: value2 });
            },
            End() {
              send({ type: "GOTO.LAST", value: value2 });
            }
          };
          const key = getEventKey(event, {
            dir: state.context.dir,
            orientation: state.context.orientation
          });
          const exec = keyMap[key];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        }
      });
    }
  };
}

// src/accordion.machine.ts
import { createMachine, guards } from "@zag-js/core";
import { add, compact, isString, remove, toArray, warn } from "@zag-js/utils";
var { and, not } = guards;
var valueMismatchMessage = `[accordion/invalid-value] Expected value for multiple accordion to be an 'array' but received 'string'. Value will be coarsed to 'array'`;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "accordion",
      initial: "idle",
      context: {
        focusedValue: null,
        value: null,
        collapsible: false,
        multiple: false,
        orientation: "vertical",
        ...ctx
      },
      watch: {
        value: "sanitizeValue",
        multiple: "sanitizeValue"
      },
      created: "sanitizeValue",
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal"
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue", "invokeOnChange"]
        }
      },
      states: {
        idle: {
          on: {
            "TRIGGER.FOCUS": {
              target: "focused",
              actions: "setFocusedValue"
            }
          }
        },
        focused: {
          on: {
            "GOTO.NEXT": {
              actions: "focusNext"
            },
            "GOTO.PREV": {
              actions: "focusPrev"
            },
            "TRIGGER.CLICK": [
              {
                guard: and("isExpanded", "canToggle"),
                actions: ["collapse", "invokeOnChange"]
              },
              {
                guard: not("isExpanded"),
                actions: ["expand", "invokeOnChange"]
              }
            ],
            "GOTO.FIRST": {
              actions: "focusFirst"
            },
            "GOTO.LAST": {
              actions: "focusLast"
            },
            "TRIGGER.BLUR": {
              target: "idle",
              actions: "clearFocusedValue"
            }
          }
        }
      }
    },
    {
      guards: {
        canToggle: (ctx2) => !!ctx2.collapsible || !!ctx2.multiple,
        isExpanded: (ctx2, evt) => {
          if (ctx2.multiple && Array.isArray(ctx2.value)) {
            return ctx2.value.includes(evt.value);
          }
          return ctx2.value === evt.value;
        }
      },
      actions: {
        invokeOnChange(ctx2) {
          ctx2.onChange?.({ value: ctx2.value });
        },
        collapse(ctx2, evt) {
          ctx2.value = ctx2.multiple ? remove(toArray(ctx2.value), evt.value) : null;
        },
        expand(ctx2, evt) {
          ctx2.value = ctx2.multiple ? add(toArray(ctx2.value), evt.value) : evt.value;
        },
        focusFirst(ctx2) {
          dom.getFirstTriggerEl(ctx2)?.focus();
        },
        focusLast(ctx2) {
          dom.getLastTriggerEl(ctx2)?.focus();
        },
        focusNext(ctx2) {
          if (!ctx2.focusedValue)
            return;
          const el = dom.getNextTriggerEl(ctx2, ctx2.focusedValue);
          el?.focus();
        },
        focusPrev(ctx2) {
          if (!ctx2.focusedValue)
            return;
          const el = dom.getPrevTriggerEl(ctx2, ctx2.focusedValue);
          el?.focus();
        },
        setFocusedValue(ctx2, evt) {
          ctx2.focusedValue = evt.value;
        },
        clearFocusedValue(ctx2) {
          ctx2.focusedValue = null;
        },
        setValue(ctx2, evt) {
          ctx2.value = evt.value;
        },
        sanitizeValue(ctx2) {
          if (ctx2.multiple && isString(ctx2.value)) {
            warn(valueMismatchMessage);
            ctx2.value = [ctx2.value];
          } else if (!ctx2.multiple && Array.isArray(ctx2.value) && ctx2.value.length > 0) {
            ctx2.value = ctx2.value[0];
          }
        }
      }
    }
  );
}
export {
  anatomy,
  connect,
  machine
};
//# sourceMappingURL=index.mjs.map