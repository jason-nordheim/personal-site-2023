"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  dispatchInputCheckedEvent: () => dispatchInputCheckedEvent,
  dispatchInputValueEvent: () => dispatchInputValueEvent,
  getClosestForm: () => getClosestForm,
  isNativeDisabled: () => isNativeDisabled,
  setElementValue: () => setElementValue,
  trackFormControl: () => trackFormControl
});
module.exports = __toCommonJS(src_exports);

// src/input-event.ts
var getWindow = (el) => el.ownerDocument.defaultView || window;
function getDescriptor(el, options) {
  const { type, property = "value" } = options;
  const proto = getWindow(el)[type].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function setElementValue(el, value, option) {
  const descriptor = getDescriptor(el, option);
  descriptor.set?.call(el, value);
}
function dispatchInputValueEvent(el, options) {
  if (!el)
    return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement))
    return;
  const { value, bubbles = true } = options;
  const descriptor = getDescriptor(el, {
    type: "HTMLInputElement",
    property: "value"
  });
  descriptor.set?.call(el, value);
  const event = new win.Event("input", { bubbles });
  el.dispatchEvent(event);
}
function dispatchInputCheckedEvent(el, options) {
  if (!el)
    return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement))
    return;
  const { checked, bubbles = true } = options;
  const descriptor = getDescriptor(el, {
    type: "HTMLInputElement",
    property: "checked"
  });
  descriptor.set?.call(el, checked);
  const event = new win.Event("click", { bubbles });
  el.dispatchEvent(event);
}

// src/form.ts
var import_mutation_observer = require("@zag-js/mutation-observer");
function getClosestForm(el) {
  if (isFormElement(el))
    return el.form;
  else
    return el.closest("form");
}
function isFormElement(el) {
  return el.matches("textarea, input, select, button");
}
function trackFormReset(el, callback) {
  if (!el)
    return;
  const form = getClosestForm(el);
  form?.addEventListener("reset", callback, { passive: true });
  return () => {
    form?.removeEventListener("reset", callback);
  };
}
function trackFieldsetDisabled(el, callback) {
  const fieldset = el?.closest("fieldset");
  if (!fieldset)
    return;
  callback(fieldset.disabled);
  return (0, import_mutation_observer.observeAttributes)(fieldset, ["disabled"], () => callback(fieldset.disabled));
}
function isNativeDisabled(el) {
  return el.matches(":disabled");
}
function trackFormControl(el, options) {
  if (!el)
    return;
  const { onFieldsetDisabled, onFormReset } = options;
  const cleanups = [
    trackFormReset(el, onFormReset),
    trackFieldsetDisabled(el, (disabled) => {
      if (disabled)
        onFieldsetDisabled();
    })
  ];
  return () => {
    cleanups.forEach((cleanup) => cleanup?.());
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  dispatchInputCheckedEvent,
  dispatchInputValueEvent,
  getClosestForm,
  isNativeDisabled,
  setElementValue,
  trackFormControl
});
//# sourceMappingURL=index.js.map