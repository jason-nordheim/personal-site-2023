// src/switch.anatomy.ts
import { createAnatomy } from "@zag-js/anatomy";
var anatomy = createAnatomy("switch").parts("root", "input", "label", "control", "thumb");
var parts = anatomy.build();

// src/switch.connect.ts
import { dataAttr } from "@zag-js/dom-query";
import { visuallyHiddenStyle } from "@zag-js/visually-hidden";

// src/switch.dom.ts
import { createScope } from "@zag-js/dom-query";
var dom = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `switch:${ctx.id}`,
  getLabelId: (ctx) => ctx.ids?.label ?? `switch:${ctx.id}:label`,
  getThumbId: (ctx) => ctx.ids?.thumb ?? `switch:${ctx.id}:thumb`,
  getControlId: (ctx) => ctx.ids?.control ?? `switch:${ctx.id}:control`,
  getInputId: (ctx) => ctx.ids?.input ?? `switch:${ctx.id}:input`,
  getInputEl: (ctx) => dom.queryById(ctx, dom.getInputId(ctx))
});

// src/switch.connect.ts
function connect(state, send, normalize) {
  const isDisabled = state.context.disabled;
  const isFocusable = state.context.focusable;
  const isFocused = !isDisabled && state.context.focused;
  const isChecked = state.context.checked;
  const dataAttrs = {
    "data-active": dataAttr(state.context.active),
    "data-focus": dataAttr(isFocused),
    "data-hover": dataAttr(state.context.hovered),
    "data-disabled": dataAttr(isDisabled),
    "data-state": state.context.checked ? "checked" : "unchecked",
    "data-invalid": dataAttr(state.context.invalid)
  };
  const trulyDisabled = isDisabled && !isFocusable;
  return {
    isChecked,
    isDisabled,
    isFocused,
    setChecked(checked) {
      send({ type: "CHECKED.SET", checked });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked: isChecked });
    },
    rootProps: normalize.label({
      ...parts.root.attrs,
      ...dataAttrs,
      id: dom.getRootId(state.context),
      htmlFor: dom.getInputId(state.context),
      onPointerMove() {
        if (isDisabled)
          return;
        send({ type: "CONTEXT.SET", context: { hovered: true } });
      },
      onPointerLeave() {
        if (isDisabled)
          return;
        send({ type: "CONTEXT.SET", context: { hovered: false } });
      },
      onPointerDown(event) {
        if (isDisabled)
          return;
        if (isFocused)
          event.preventDefault();
        send({ type: "CONTEXT.SET", context: { active: true } });
      },
      onPointerUp() {
        if (isDisabled)
          return;
        send({ type: "CONTEXT.SET", context: { active: false } });
      },
      onClick(event) {
        if (event.target === dom.getInputEl(state.context)) {
          event.stopPropagation();
        }
      }
    }),
    labelProps: normalize.element({
      ...parts.label.attrs,
      ...dataAttrs,
      id: dom.getLabelId(state.context)
    }),
    thumbProps: normalize.element({
      ...parts.thumb.attrs,
      ...dataAttrs,
      id: dom.getThumbId(state.context),
      "aria-hidden": true
    }),
    controlProps: normalize.element({
      ...parts.control.attrs,
      ...dataAttrs,
      id: dom.getControlId(state.context),
      "aria-hidden": true
    }),
    inputProps: normalize.input({
      ...parts.input.attrs,
      id: dom.getInputId(state.context),
      type: "checkbox",
      required: state.context.required,
      defaultChecked: isChecked,
      "data-focus": dataAttr(isFocused),
      "data-hover": dataAttr(state.context.hovered),
      disabled: trulyDisabled,
      "data-disabled": dataAttr(isDisabled),
      "aria-labelledby": dom.getLabelId(state.context),
      "aria-invalid": state.context.invalid,
      name: state.context.name,
      form: state.context.form,
      value: state.context.value,
      style: visuallyHiddenStyle,
      onChange(event) {
        const checked = event.currentTarget.checked;
        send({ type: "CHECKED.SET", checked });
      },
      onBlur() {
        send({ type: "CONTEXT.SET", context: { focused: false } });
      },
      onFocus() {
        send({ type: "CONTEXT.SET", context: { focused: true } });
      },
      onKeyDown(event) {
        if (event.key === " ") {
          send({ type: "CONTEXT.SET", context: { active: true } });
        }
      },
      onKeyUp(event) {
        if (event.key === " ") {
          send({ type: "CONTEXT.SET", context: { active: false } });
        }
      }
    })
  };
}

// src/switch.machine.ts
import { createMachine } from "@zag-js/core";
import { dispatchInputCheckedEvent, trackFormControl } from "@zag-js/form-utils";
import { compact } from "@zag-js/utils";
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "switch",
      initial: "ready",
      context: {
        checked: false,
        label: "switch",
        value: "on",
        ...ctx
      },
      watch: {
        disabled: "removeFocusIfNeeded",
        checked: ["invokeOnChange", "syncInputElement"]
      },
      activities: ["trackFormControlState"],
      on: {
        "CHECKED.TOGGLE": {
          actions: ["toggleChecked"]
        },
        "CHECKED.SET": {
          actions: ["setChecked"]
        },
        "CONTEXT.SET": {
          actions: ["setContext"]
        }
      },
      states: {
        ready: {}
      }
    },
    {
      activities: {
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom.getInputEl(ctx2), {
            onFieldsetDisabled() {
              ctx2.disabled = true;
            },
            onFormReset() {
              send({ type: "CHECKED.SET", checked: !!initialContext.checked });
            }
          });
        }
      },
      actions: {
        invokeOnChange(ctx2) {
          ctx2.onChange?.({ checked: ctx2.checked });
        },
        setContext(ctx2, evt) {
          Object.assign(ctx2, evt.context);
        },
        syncInputElement(ctx2) {
          const inputEl = dom.getInputEl(ctx2);
          inputEl.checked = !!ctx2.checked;
        },
        dispatchChangeEvent(ctx2, evt) {
          const inputEl = dom.getInputEl(ctx2);
          const checked = evt.checked;
          dispatchInputCheckedEvent(inputEl, { checked, bubbles: true });
        },
        removeFocusIfNeeded(ctx2) {
          if (ctx2.disabled && ctx2.focused) {
            ctx2.focused = false;
          }
        },
        setChecked(ctx2, evt) {
          ctx2.checked = evt.checked;
        },
        toggleChecked(ctx2, _evt) {
          ctx2.checked = !ctx2.checked;
        }
      }
    }
  );
}
export {
  anatomy,
  connect,
  machine
};
//# sourceMappingURL=index.mjs.map